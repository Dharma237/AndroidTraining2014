package com.pcs.swipelisttodelete;

import android.graphics.Rect;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.ListView;
import com.nineoldandroids.animation.Animator;
import com.nineoldandroids.animation.AnimatorListenerAdapter;
import com.nineoldandroids.animation.ValueAnimator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static com.nineoldandroids.view.ViewHelper.setAlpha;
import static com.nineoldandroids.view.ViewHelper.setTranslationX;
import static com.nineoldandroids.view.ViewPropertyAnimator.animate;

public class SwipeDismissListViewTouchListener implements View.OnTouchListener {

   private int slop;
   private int minFlingVelocity;
   private int maxFlingVelocity;
   private long animationTime;

   private ListView listView;
   private OnDismissCallback callback;
   private int viewWidth = 1; // 1 and not 0 to prevent dividing by zero

   // Transient properties
   private List<PendingDismissData> pendingDismisses = new ArrayList<PendingDismissData>();
   private int dismissAnimationRefCount = 0;
   private float downX;
   private boolean swiping;
   private VelocityTracker velocityTracker;
   private int downPosition;
   private View downView;
   private boolean paused;

   public interface OnDismissCallback {
   
       void onDismiss(ListView listView, int[] reverseSortedPositions);
   }

   public SwipeDismissListViewTouchListener(ListView listView, OnDismissCallback callback) {
       ViewConfiguration vc = ViewConfiguration.get(listView.getContext());
       slop = vc.getScaledTouchSlop();
       minFlingVelocity = vc.getScaledMinimumFlingVelocity();
       maxFlingVelocity = vc.getScaledMaximumFlingVelocity();
       animationTime = listView.getContext().getResources().getInteger(
               android.R.integer.config_shortAnimTime);
       listView = listView;
       callback = callback;
   }

 
   public void setEnabled(boolean enabled) {
       paused = !enabled;
   }

 
   public AbsListView.OnScrollListener makeScrollListener() {
       return new AbsListView.OnScrollListener() {
           @Override
           public void onScrollStateChanged(AbsListView absListView, int scrollState) {
               setEnabled(scrollState != AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
           }

           @Override
           public void onScroll(AbsListView absListView, int i, int i1, int i2) {
           }
       };
   }

   @Override
   public boolean onTouch(View view, MotionEvent motionEvent) {
       if (viewWidth < 2) {
           viewWidth = listView.getWidth();
       }

       switch (motionEvent.getActionMasked()) {
           case MotionEvent.ACTION_DOWN: {
               if (paused) {
                   return false;
               }            

               // Find the child view that was touched (perform a hit test)
               Rect rect = new Rect();
               int childCount = listView.getChildCount();
               int[] listViewCoords = new int[2];
               listView.getLocationOnScreen(listViewCoords);
               int x = (int) motionEvent.getRawX() - listViewCoords[0];
               int y = (int) motionEvent.getRawY() - listViewCoords[1];
               View child;
               for (int i = 0; i < childCount; i++) {
                   child = listView.getChildAt(i);
                   child.getHitRect(rect);
                   if (rect.contains(x, y)) {
                       downView = child;
                       break;
                   }
               }

               if (downView != null) {
                   downX = motionEvent.getRawX();
                   downPosition = listView.getPositionForView(downView);

                   velocityTracker = VelocityTracker.obtain();
                   velocityTracker.addMovement(motionEvent);
               }
               view.onTouchEvent(motionEvent);
               return true;
           }

           case MotionEvent.ACTION_UP: {
               if (velocityTracker == null) {
                   break;
               }

               float deltaX = motionEvent.getRawX() - downX;
               velocityTracker.addMovement(motionEvent);
               velocityTracker.computeCurrentVelocity(1000);
               float velocityX = Math.abs(velocityTracker.getXVelocity());
               float velocityY = Math.abs(velocityTracker.getYVelocity());
               boolean dismiss = false;
               boolean dismissRight = false;
               if (Math.abs(deltaX) > viewWidth / 2) {
                   dismiss = true;
                   dismissRight = deltaX > 0;
               } else if (minFlingVelocity <= velocityX && velocityX <=maxFlingVelocity
                       && velocityY < velocityX) {
                   dismiss = true;
                   dismissRight = velocityTracker.getXVelocity() > 0;
               }
               if (dismiss) {
                   // dismiss
                   final View downView = downView; // mDownView gets null'd before animation ends
                   final int downPosition = downPosition;
                   ++dismissAnimationRefCount;
                   animate(downView)
                           .translationX(dismissRight ? viewWidth : -viewWidth)
                           .alpha(0)
                           .setDuration(animationTime)
                           .setListener(new AnimatorListenerAdapter() {
                               @Override
                               public void onAnimationEnd(Animator animation) {
                                   performDismiss(downView, downPosition);
                               }
                           });
               } else {
                   // cancel
                   animate(downView)
                           .translationX(0)
                           .alpha(1)
                           .setDuration(animationTime)
                           .setListener(null);
               }
               velocityTracker = null;
               downX = 0;
               downView = null;
               downPosition = ListView.INVALID_POSITION;
               swiping = false;
               break;
           }

           case MotionEvent.ACTION_MOVE: {
               if (velocityTracker == null || paused) {
                   break;
               }

               velocityTracker.addMovement(motionEvent);
               float deltaX = motionEvent.getRawX() - downX;
               if (Math.abs(deltaX) > slop) {
                   swiping = true;
                   listView.requestDisallowInterceptTouchEvent(true);

                   // Cancel ListView's touch (un-highlighting the item)
                   MotionEvent cancelEvent = MotionEvent.obtain(motionEvent);
                   cancelEvent.setAction(MotionEvent.ACTION_CANCEL |
                           (motionEvent.getActionIndex()
                                   << MotionEvent.ACTION_POINTER_INDEX_SHIFT));
                   listView.onTouchEvent(cancelEvent);
               }

               if (swiping) {
                   setTranslationX(downView, deltaX);
                   setAlpha(downView, Math.max(0f, Math.min(1f,
                           1f - 2f * Math.abs(deltaX) / viewWidth)));
                   return true;
               }
               break;
           }
       }
       return false;
   }

   class PendingDismissData implements Comparable<PendingDismissData> {
       public int position;
       public View view;

       public PendingDismissData(int position, View view) {
           this.position = position;
           this.view = view;
       }

       @Override
       public int compareTo(PendingDismissData other) {
           // Sort by descending position
           return other.position - position;
       }
   }

   private void performDismiss(final View dismissView, final int dismissPosition) {
       // Animate the dismissed list item to zero-height and fire the dismiss callback when
       // all dismissed list item animations have completed. This triggers layout on each animation
       // frame; in the future we may want to do something smarter and more performant.

       final ViewGroup.LayoutParams lp = dismissView.getLayoutParams();
       final int originalHeight = dismissView.getHeight();

       ValueAnimator animator = ValueAnimator.ofInt(originalHeight, 1).setDuration(animationTime);

       animator.addListener(new AnimatorListenerAdapter() {
           @Override
           public void onAnimationEnd(Animator animation) {
               --dismissAnimationRefCount;
               if (dismissAnimationRefCount == 0) {
                   // No active animations, process all pending dismisses.
                   // Sort by descending position
                   Collections.sort(pendingDismisses);

                   int[] dismissPositions = new int[pendingDismisses.size()];
                   for (int i = pendingDismisses.size() - 1; i >= 0; i--) {
                       dismissPositions[i] = pendingDismisses.get(i).position;
                   }
                   callback.onDismiss(listView, dismissPositions);

                   ViewGroup.LayoutParams lp;
                   for (PendingDismissData pendingDismiss : pendingDismisses) {
                       // Reset view presentation
                       setAlpha(pendingDismiss.view, 1f);
                       setTranslationX(pendingDismiss.view, 0);
                       lp = pendingDismiss.view.getLayoutParams();
                       lp.height = originalHeight;
                       pendingDismiss.view.setLayoutParams(lp);
                   }

                   pendingDismisses.clear();
               }
           }
       });

       animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
           @Override
           public void onAnimationUpdate(ValueAnimator valueAnimator) {
               lp.height = (Integer) valueAnimator.getAnimatedValue();
               dismissView.setLayoutParams(lp);
           }
       });

       pendingDismisses.add(new PendingDismissData(dismissPosition, dismissView));
       animator.start();
   }


}
